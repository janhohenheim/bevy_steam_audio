use std::time::Duration;

use crate::{prelude::*, wrapper::AudionimbusCoordinateSystem};

pub(super) fn plugin(app: &mut App) {
    app.init_resource::<SteamAudioEnabled>()
        .init_resource::<SteamAudioQuality>()
        .init_resource::<SteamAudioPathingSettings>();
}

#[derive(Debug, Clone, PartialEq, Reflect, Resource)]
#[reflect(Resource)]
pub struct SteamAudioEnabled {
    pub enabled: bool,
    pub reflection_and_pathing_simulation_timer: Option<Timer>,
}

#[derive(Debug, Clone, Copy, PartialEq, Reflect, Resource)]
#[reflect(Resource)]
pub struct SteamAudioQuality {
    pub order: u32,
    pub frame_size: u32,
    /// The number of times each ray traced from the listener is reflected when it encounters a solid object.
    /// Increasing this value results in longer, more accurate reverb tails, at the cost of increased CPU usage during simulation.
    pub num_bounces: u32,

    /// When calculating how much sound energy reaches a surface directly from a source, any source that is closer than [`Self::irradiance_min_distance`] to the surface is assumed to be at a distance of [`Self::irradiance_min_distance`], for the purposes of energy calculations.
    pub irradiance_min_distance: f32,

    pub direct: SteamAudioDirectQuality,
    pub reflections: SteamAudioReflectionsQuality,
    pub pathing: SteamAudioPathingQuality,
}

/// Settings used for direct path simulation.
#[derive(Debug, Clone, Copy, PartialEq, Reflect)]
pub struct SteamAudioDirectQuality {
    /// The maximum number of point samples to consider when calculating occlusion using the volumetric occlusion algorithm.
    /// Different sources can use different numbers of samples, and the number of samples can change between simulation runs, but this is the maximum value.
    /// Increasing this value results in smoother occlusion transitions, at the cost of increased CPU usage.
    pub max_num_occlusion_samples: u32,
}

impl From<SteamAudioDirectQuality> for audionimbus::DirectSimulationSettings {
    fn from(settings: SteamAudioDirectQuality) -> Self {
        Self {
            max_num_occlusion_samples: settings.max_num_occlusion_samples,
        }
    }
}

impl Default for SteamAudioDirectQuality {
    fn default() -> Self {
        Self {
            max_num_occlusion_samples: 16,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Reflect)]
/// Settings used for pathing simulation.
pub struct SteamAudioPathingQuality {
    /// The number of point samples to consider when calculating probe-to-probe visibility for pathing simulations.
    /// Baked paths may end up being occluded by dynamic objects, in which case you can configure the simulator to look for alternate paths in real time.
    /// This process will involve checking visibility between probes.
    num_visibility_samples: u32,
}

impl From<SteamAudioPathingQuality> for audionimbus::PathingSimulationSettings {
    fn from(settings: SteamAudioPathingQuality) -> Self {
        Self {
            num_visibility_samples: settings.num_visibility_samples,
        }
    }
}

impl Default for SteamAudioPathingQuality {
    fn default() -> Self {
        Self {
            num_visibility_samples: 32,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Reflect)]
/// Settings used for reflections simulation.
pub struct SteamAudioReflectionsQuality {
    /// The maximum number of rays to trace from the listener when simulating reflections.
    /// Increasing this value results in more accurate reflections, at the cost of increased CPU usage.
    pub num_rays: u32,
    /// The number of directions to sample when generating diffusely reflected rays.
    /// Increasing this value may increase the accuracy of diffuse reflections.
    pub num_diffuse_samples: u32,
    /// The maximum length of time of impulse responses generated by reflection simulations.
    /// Increasing this value results in longer, more accurate reverb tails, at the cost of increased CPU and memory usage.
    pub impulse_duration: Duration,
    /// The maximum number of sources for which reflection simulations will be run at any given time.
    pub max_num_sources: u32,
    /// The number of threads used for real-time reflection simulations.
    pub num_threads: u32,
    pub kind: SteamAudioReflectionKind,
}

#[derive(Debug, Clone, Copy, PartialEq, Reflect)]
/// Settings used for reflections simulation.
pub enum SteamAudioReflectionKind {
    /// Multi-channel convolution reverb.
    Convolution,

    /// Parametric (or artificial) reverb, using feedback delay networks.
    Parametric,

    /// A hybrid of convolution and parametric reverb.
    Hybrid,
}

impl From<SteamAudioReflectionKind> for audionimbus::ReflectionEffectType {
    fn from(kind: SteamAudioReflectionKind) -> Self {
        match kind {
            SteamAudioReflectionKind::Convolution => audionimbus::ReflectionEffectType::Convolution,
            SteamAudioReflectionKind::Parametric => audionimbus::ReflectionEffectType::Parametric,
            SteamAudioReflectionKind::Hybrid => audionimbus::ReflectionEffectType::Hybrid,
        }
    }
}

impl SteamAudioReflectionsQuality {
    pub(crate) fn to_audionimbus(
        self,
        order: u32,
    ) -> audionimbus::ReflectionsSimulationSettings<'static> {
        match self.kind {
            SteamAudioReflectionKind::Convolution => {
                audionimbus::ReflectionsSimulationSettings::Convolution {
                    max_num_rays: self.num_rays,
                    num_diffuse_samples: self.num_diffuse_samples,
                    max_duration: self.impulse_duration.as_secs_f32(),
                    max_order: order,
                    max_num_sources: self.max_num_sources,
                    num_threads: self.num_threads,
                }
            }
            SteamAudioReflectionKind::Parametric => {
                audionimbus::ReflectionsSimulationSettings::Parametric {
                    max_num_rays: self.num_rays,
                    num_diffuse_samples: self.num_diffuse_samples,
                    max_duration: self.impulse_duration.as_secs_f32(),
                    max_order: order,
                    max_num_sources: self.max_num_sources,
                    num_threads: self.num_threads,
                }
            }
            SteamAudioReflectionKind::Hybrid => {
                audionimbus::ReflectionsSimulationSettings::Hybrid {
                    max_num_rays: self.num_rays,
                    num_diffuse_samples: self.num_diffuse_samples,
                    max_duration: self.impulse_duration.as_secs_f32(),
                    max_order: order,
                    max_num_sources: self.max_num_sources,
                    num_threads: self.num_threads,
                }
            }
        }
    }
}

impl Default for SteamAudioReflectionsQuality {
    fn default() -> Self {
        Self {
            num_rays: 4096,
            num_diffuse_samples: 32,
            impulse_duration: Duration::from_secs_f32(2.0),
            max_num_sources: 8,
            num_threads: 2,
            kind: SteamAudioReflectionKind::Convolution,
        }
    }
}

#[inline]
pub(crate) fn order_to_num_channels(order: u32) -> u32 {
    (order + 1).pow(2)
}

impl SteamAudioQuality {
    pub(crate) fn to_audionimbus_simulation_shared_inputs(
        self,
        listener_position: AudionimbusCoordinateSystem,
    ) -> audionimbus::SimulationSharedInputs {
        audionimbus::SimulationSharedInputs {
            num_rays: self.reflections.num_rays,
            num_bounces: self.num_bounces,
            duration: self.reflections.impulse_duration.as_secs_f32(),
            irradiance_min_distance: self.irradiance_min_distance,
            listener: listener_position.into(),
            order: self.order,
            pathing_visualization_callback: None,
        }
    }

    pub(crate) fn impulse_response_size(self, sampling_rate: u32) -> u32 {
        (self.reflections.impulse_duration.as_secs_f32() * sampling_rate as f32).ceil() as u32
    }

    pub fn num_channels(self) -> u32 {
        order_to_num_channels(self.order)
    }
}

impl Default for SteamAudioQuality {
    fn default() -> Self {
        Self {
            order: 2,
            frame_size: 1024,
            num_bounces: 4,
            irradiance_min_distance: 1.0,
            direct: default(),
            reflections: default(),
            pathing: default(),
        }
    }
}

impl Default for SteamAudioEnabled {
    fn default() -> Self {
        Self {
            enabled: true,
            reflection_and_pathing_simulation_timer: Some(Timer::from_seconds(
                0.1,
                TimerMode::Once,
            )),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Reflect, Resource)]
#[reflect(Resource)]
pub struct SteamAudioPathingSettings {
    /// When testing for mutual visibility between a pair of probes, each probe is treated as a sphere of this radius (in meters), and point samples are generated within this sphere.
    pub visibility_radius: f32,
    /// When tracing rays to test for mutual visibility between a pair of probes, the fraction of rays that are unoccluded must be greater than this threshold for the pair of probes to be considered mutually visible.
    pub visibility_threshold: f32,
    /// If the distance between two probes is greater than this value, the probes are not considered mutually visible.
    /// Increasing this value can result in simpler paths, at the cost of increased CPU usage.
    pub visibility_range: f32,
}

impl Default for SteamAudioPathingSettings {
    fn default() -> Self {
        Self {
            visibility_radius: 1.0,
            visibility_threshold: 0.1,
            visibility_range: 1000.0,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Resource)]
pub struct SteamAudioHrtf(pub audionimbus::Hrtf);
